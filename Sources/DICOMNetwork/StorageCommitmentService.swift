import Foundation
import DICOMCore

// MARK: - Storage Commitment SOP Class UIDs

/// Storage Commitment Push Model SOP Class UID
///
/// Used for Storage Commitment requests via N-ACTION and N-EVENT-REPORT.
///
/// Reference: PS3.4 Annex J - Storage Commitment Service Class
public let storageCommitmentPushModelSOPClassUID = "1.2.840.10008.1.20.1"

/// Storage Commitment Push Model SOP Instance UID (Well-Known)
///
/// The well-known SOP Instance UID for the Storage Commitment Push Model.
///
/// Reference: PS3.4 Annex J.3
public let storageCommitmentPushModelSOPInstanceUID = "1.2.840.10008.1.20.1.1"

// MARK: - Storage Commitment Action/Event Type IDs

/// Action Type ID for Storage Commitment Request
///
/// Used in N-ACTION-RQ to request storage commitment.
/// Value: 1 (Request Storage Commitment)
///
/// Reference: PS3.4 Table J.3-1
public let storageCommitmentRequestActionTypeID: UInt16 = 1

/// Event Type ID for Storage Commitment Result - Success
///
/// Used in N-EVENT-REPORT-RQ when all instances are committed.
/// Value: 1 (Storage Commitment Request Successful)
///
/// Reference: PS3.4 Table J.3-2
public let storageCommitmentSuccessEventTypeID: UInt16 = 1

/// Event Type ID for Storage Commitment Result - Failure
///
/// Used in N-EVENT-REPORT-RQ when some instances failed commitment.
/// Value: 2 (Storage Commitment Request Complete - Failures Exist)
///
/// Reference: PS3.4 Table J.3-2
public let storageCommitmentFailureEventTypeID: UInt16 = 2

// MARK: - SOP Reference

/// A reference to a stored SOP Instance
///
/// Represents a single DICOM object by its SOP Class and Instance UIDs.
/// Used in Storage Commitment requests to identify instances to commit.
///
/// Reference: PS3.4 Table J.3-1
public struct SOPReference: Sendable, Hashable {
    /// The SOP Class UID of the referenced instance
    public let sopClassUID: String
    
    /// The SOP Instance UID of the referenced instance
    public let sopInstanceUID: String
    
    /// Creates a SOP reference
    ///
    /// - Parameters:
    ///   - sopClassUID: The SOP Class UID
    ///   - sopInstanceUID: The SOP Instance UID
    public init(sopClassUID: String, sopInstanceUID: String) {
        self.sopClassUID = sopClassUID
        self.sopInstanceUID = sopInstanceUID
    }
}

extension SOPReference: CustomStringConvertible {
    public var description: String {
        "SOPReference(class: \(sopClassUID), instance: \(sopInstanceUID))"
    }
}

// MARK: - Failed SOP Reference

/// A SOP reference with failure information
///
/// Represents a SOP Instance that failed storage commitment, including
/// the reason for failure.
///
/// Reference: PS3.4 Table J.3-2
public struct FailedSOPReference: Sendable, Hashable {
    /// The SOP reference that failed
    public let reference: SOPReference
    
    /// The failure reason code
    ///
    /// Common failure reasons:
    /// - 0x0110: Processing failure
    /// - 0x0112: No such object instance
    /// - 0x0213: Resource limitation
    /// - 0x0122: Referenced SOP Class not supported
    ///
    /// Reference: PS3.4 Table J.3-2
    public let failureReason: UInt16
    
    /// Creates a failed SOP reference
    ///
    /// - Parameters:
    ///   - reference: The SOP reference that failed
    ///   - failureReason: The failure reason code
    public init(reference: SOPReference, failureReason: UInt16) {
        self.reference = reference
        self.failureReason = failureReason
    }
    
    /// Human-readable failure reason description
    public var failureReasonDescription: String {
        switch failureReason {
        case 0x0110:
            return "Processing failure"
        case 0x0112:
            return "No such object instance"
        case 0x0213:
            return "Resource limitation"
        case 0x0122:
            return "Referenced SOP Class not supported"
        case 0x0119:
            return "Class/Instance conflict"
        case 0x0131:
            return "Duplicate SOP Instance"
        default:
            return "Unknown failure reason (0x\(String(format: "%04X", failureReason)))"
        }
    }
}

extension FailedSOPReference: CustomStringConvertible {
    public var description: String {
        "FailedSOPReference(\(reference), reason: \(failureReasonDescription))"
    }
}

// MARK: - Commitment Request

/// A Storage Commitment request
///
/// Represents an outstanding request for storage commitment.
/// Contains the transaction UID and the instances being committed.
///
/// Reference: PS3.4 Annex J.3
public struct CommitmentRequest: Sendable, Hashable {
    /// The unique Transaction UID for this commitment request
    ///
    /// Generated by the SCU and used to correlate requests with results.
    public let transactionUID: String
    
    /// The SOP references being committed
    public let references: [SOPReference]
    
    /// The timestamp when the request was created
    public let timestamp: Date
    
    /// The remote AE title that received the request
    public let remoteAETitle: String
    
    /// Creates a commitment request
    ///
    /// - Parameters:
    ///   - transactionUID: The transaction UID
    ///   - references: The SOP references to commit
    ///   - timestamp: The timestamp (default: now)
    ///   - remoteAETitle: The remote AE title
    public init(
        transactionUID: String,
        references: [SOPReference],
        timestamp: Date = Date(),
        remoteAETitle: String
    ) {
        self.transactionUID = transactionUID
        self.references = references
        self.timestamp = timestamp
        self.remoteAETitle = remoteAETitle
    }
}

extension CommitmentRequest: CustomStringConvertible {
    public var description: String {
        "CommitmentRequest(txn: \(transactionUID), count: \(references.count), ae: \(remoteAETitle))"
    }
}

// MARK: - Commitment Result

/// The result of a Storage Commitment request
///
/// Contains information about which instances were successfully committed
/// and which failed, along with the transaction UID for correlation.
///
/// Reference: PS3.4 Annex J.3
public struct CommitmentResult: Sendable, Hashable {
    /// The Transaction UID that correlates this result with a request
    public let transactionUID: String
    
    /// The SOP references that were successfully committed
    public let committedReferences: [SOPReference]
    
    /// The SOP references that failed commitment
    public let failedReferences: [FailedSOPReference]
    
    /// The timestamp when the result was received
    public let timestamp: Date
    
    /// The remote AE title that sent the result
    public let remoteAETitle: String
    
    /// Whether all instances were successfully committed
    public var isSuccess: Bool {
        failedReferences.isEmpty
    }
    
    /// Whether the commitment was partially successful (some instances committed)
    public var isPartialSuccess: Bool {
        !committedReferences.isEmpty && !failedReferences.isEmpty
    }
    
    /// Whether all instances failed commitment
    public var isFailure: Bool {
        committedReferences.isEmpty && !failedReferences.isEmpty
    }
    
    /// The total number of instances in the result
    public var totalCount: Int {
        committedReferences.count + failedReferences.count
    }
    
    /// Creates a commitment result
    ///
    /// - Parameters:
    ///   - transactionUID: The transaction UID
    ///   - committedReferences: Successfully committed references
    ///   - failedReferences: Failed references with reasons
    ///   - timestamp: The timestamp (default: now)
    ///   - remoteAETitle: The remote AE title
    public init(
        transactionUID: String,
        committedReferences: [SOPReference],
        failedReferences: [FailedSOPReference],
        timestamp: Date = Date(),
        remoteAETitle: String
    ) {
        self.transactionUID = transactionUID
        self.committedReferences = committedReferences
        self.failedReferences = failedReferences
        self.timestamp = timestamp
        self.remoteAETitle = remoteAETitle
    }
}

extension CommitmentResult: CustomStringConvertible {
    public var description: String {
        let status = isSuccess ? "SUCCESS" : (isPartialSuccess ? "PARTIAL" : "FAILED")
        return "CommitmentResult(\(status), txn: \(transactionUID), committed: \(committedReferences.count), failed: \(failedReferences.count))"
    }
}

// MARK: - Storage Commitment Configuration

/// Configuration for the Storage Commitment Service
public struct StorageCommitmentConfiguration: Sendable, Hashable {
    /// The local Application Entity title (calling AE)
    public let callingAETitle: AETitle
    
    /// The remote Application Entity title (called AE)
    public let calledAETitle: AETitle
    
    /// Connection timeout in seconds
    public let timeout: TimeInterval
    
    /// Maximum PDU size to propose
    public let maxPDUSize: UInt32
    
    /// Implementation Class UID for this DICOM implementation
    public let implementationClassUID: String
    
    /// Implementation Version Name (optional)
    public let implementationVersionName: String?
    
    /// Default Implementation Class UID for DICOMKit
    public static let defaultImplementationClassUID = "1.2.826.0.1.3680043.9.7433.1.1"
    
    /// Default Implementation Version Name for DICOMKit
    public static let defaultImplementationVersionName = "DICOMKIT_001"
    
    /// Creates a storage commitment configuration
    ///
    /// - Parameters:
    ///   - callingAETitle: The local AE title
    ///   - calledAETitle: The remote AE title
    ///   - timeout: Connection timeout in seconds (default: 60)
    ///   - maxPDUSize: Maximum PDU size (default: 16KB)
    ///   - implementationClassUID: Implementation Class UID
    ///   - implementationVersionName: Implementation Version Name
    public init(
        callingAETitle: AETitle,
        calledAETitle: AETitle,
        timeout: TimeInterval = 60,
        maxPDUSize: UInt32 = defaultMaxPDUSize,
        implementationClassUID: String = defaultImplementationClassUID,
        implementationVersionName: String? = defaultImplementationVersionName
    ) {
        self.callingAETitle = callingAETitle
        self.calledAETitle = calledAETitle
        self.timeout = timeout
        self.maxPDUSize = maxPDUSize
        self.implementationClassUID = implementationClassUID
        self.implementationVersionName = implementationVersionName
    }
}

// MARK: - Commitment Notification Listener Configuration

/// Configuration for the Commitment Notification Listener
///
/// Defines the settings for receiving N-EVENT-REPORT notifications for storage commitment.
///
/// Reference: PS3.4 Annex J - Storage Commitment Service Class
public struct CommitmentNotificationListenerConfiguration: Sendable, Hashable {
    /// The local Application Entity title
    public let aeTitle: AETitle
    
    /// The port to listen on for incoming N-EVENT-REPORT
    public let port: UInt16
    
    /// Maximum PDU size to accept
    public let maxPDUSize: UInt32
    
    /// Implementation Class UID for this DICOM implementation
    public let implementationClassUID: String
    
    /// Implementation Version Name (optional)
    public let implementationVersionName: String?
    
    /// Maximum number of concurrent associations
    public let maxConcurrentAssociations: Int
    
    /// Calling AE Title whitelist
    /// If nil, all calling AE titles are accepted
    public let callingAEWhitelist: Set<String>?
    
    /// Default Implementation Class UID for DICOMKit Commitment Listener
    public static let defaultImplementationClassUID = "1.2.826.0.1.3680043.9.7433.1.4"
    
    /// Default Implementation Version Name for DICOMKit Commitment Listener
    public static let defaultImplementationVersionName = "DICOMKIT_CMTLSN"
    
    /// Creates a commitment notification listener configuration
    ///
    /// - Parameters:
    ///   - aeTitle: The local AE title
    ///   - port: The port to listen on (default: 11113)
    ///   - maxPDUSize: Maximum PDU size (default: 16KB)
    ///   - implementationClassUID: Implementation Class UID
    ///   - implementationVersionName: Implementation Version Name
    ///   - maxConcurrentAssociations: Maximum concurrent associations (default: 5)
    ///   - callingAEWhitelist: Whitelist of calling AE titles
    public init(
        aeTitle: AETitle,
        port: UInt16 = 11113,
        maxPDUSize: UInt32 = defaultMaxPDUSize,
        implementationClassUID: String = defaultImplementationClassUID,
        implementationVersionName: String? = defaultImplementationVersionName,
        maxConcurrentAssociations: Int = 5,
        callingAEWhitelist: Set<String>? = nil
    ) {
        self.aeTitle = aeTitle
        self.port = port
        self.maxPDUSize = maxPDUSize
        self.implementationClassUID = implementationClassUID
        self.implementationVersionName = implementationVersionName
        self.maxConcurrentAssociations = max(1, maxConcurrentAssociations)
        self.callingAEWhitelist = callingAEWhitelist
    }
    
    /// Checks if a calling AE title is allowed
    ///
    /// - Parameter callingAE: The calling AE title to check
    /// - Returns: True if the calling AE is allowed
    public func isCallingAEAllowed(_ callingAE: String) -> Bool {
        if let whitelist = callingAEWhitelist {
            return whitelist.contains(callingAE)
        }
        return true
    }
}

// MARK: - Commitment Notification Listener Event

/// Events emitted by the Commitment Notification Listener
public enum CommitmentNotificationListenerEvent: Sendable {
    /// Listener started
    case started(port: UInt16)
    
    /// Listener stopped
    case stopped
    
    /// An association was established
    case associationEstablished(callingAE: String)
    
    /// An association was released
    case associationReleased(callingAE: String)
    
    /// An association was rejected
    case associationRejected(callingAE: String, reason: String)
    
    /// A commitment result was received
    case resultReceived(CommitmentResult)
    
    /// An error occurred
    case error(Error)
}

#if canImport(Network)

// MARK: - Storage Commitment Service

/// Service for requesting Storage Commitment from a DICOM SCP
///
/// The Storage Commitment Service provides functionality for:
/// - Requesting storage commitment for stored DICOM instances (N-ACTION)
/// - Processing commitment notifications (N-EVENT-REPORT)
/// - Tracking pending commitment requests
///
/// ## Example Usage
///
/// ```swift
/// let callingAE = try AETitle("MY_SCU")
/// let calledAE = try AETitle("PACS")
/// let config = StorageCommitmentConfiguration(
///     callingAETitle: callingAE,
///     calledAETitle: calledAE
/// )
///
/// // Request commitment for stored instances
/// let request = try await StorageCommitmentService.requestCommitment(
///     for: [
///         SOPReference(sopClassUID: ctImageStorageSOPClassUID, sopInstanceUID: "1.2.3.4.5")
///     ],
///     host: "pacs.example.com",
///     port: 104,
///     configuration: config
/// )
///
/// print("Commitment requested: \(request.transactionUID)")
/// ```
///
/// Reference: PS3.4 Annex J - Storage Commitment Service Class
public enum StorageCommitmentService {
    
    /// Requests storage commitment for the specified SOP instances
    ///
    /// Sends an N-ACTION-RQ to the remote SCP requesting commitment for
    /// the specified instances. The SCP will later send an N-EVENT-REPORT
    /// (potentially on a new association) with the commitment result.
    ///
    /// - Parameters:
    ///   - references: The SOP references to commit
    ///   - host: The remote host address
    ///   - port: The remote port number (default: 104)
    ///   - configuration: The service configuration
    /// - Returns: A `CommitmentRequest` representing the pending commitment
    /// - Throws: `DICOMNetworkError` if the request fails
    ///
    /// Reference: PS3.4 Section J.3.1 - N-ACTION Service
    public static func requestCommitment(
        for references: [SOPReference],
        host: String,
        port: UInt16 = dicomDefaultPort,
        configuration: StorageCommitmentConfiguration
    ) async throws -> CommitmentRequest {
        guard !references.isEmpty else {
            throw DICOMNetworkError.encodingFailed("At least one SOP reference is required")
        }
        
        // Generate a unique Transaction UID
        let transactionUID = UIDGenerator.generateUID().value
        
        // Create association configuration
        let associationConfig = AssociationConfiguration(
            callingAETitle: configuration.callingAETitle,
            calledAETitle: configuration.calledAETitle,
            host: host,
            port: port,
            maxPDUSize: configuration.maxPDUSize,
            implementationClassUID: configuration.implementationClassUID,
            implementationVersionName: configuration.implementationVersionName,
            timeout: configuration.timeout
        )
        
        // Create association
        let association = Association(configuration: associationConfig)
        
        // Create presentation context for Storage Commitment
        let presentationContext = try PresentationContext(
            id: 1,
            abstractSyntax: storageCommitmentPushModelSOPClassUID,
            transferSyntaxes: [
                explicitVRLittleEndianTransferSyntaxUID,
                implicitVRLittleEndianTransferSyntaxUID
            ]
        )
        
        do {
            // Establish association
            let negotiated = try await association.request(presentationContexts: [presentationContext])
            
            // Verify that Storage Commitment was accepted
            guard negotiated.isContextAccepted(1) else {
                try await association.abort()
                throw DICOMNetworkError.sopClassNotSupported(storageCommitmentPushModelSOPClassUID)
            }
            
            // Perform the N-ACTION request
            let response = try await performNAction(
                association: association,
                presentationContextID: 1,
                maxPDUSize: negotiated.maxPDUSize,
                transactionUID: transactionUID,
                references: references
            )
            
            // Check response status
            guard response.status.isSuccess else {
                try await association.abort()
                throw DICOMNetworkError.queryFailed(response.status)
            }
            
            // Release association gracefully
            try await association.release()
            
            // Return the commitment request
            return CommitmentRequest(
                transactionUID: transactionUID,
                references: references,
                remoteAETitle: configuration.calledAETitle.value
            )
            
        } catch {
            // Attempt to abort on error
            try? await association.abort()
            throw error
        }
    }
    
    /// Waits for a commitment result for a previously requested commitment
    ///
    /// This method starts or uses an existing notification listener to wait for
    /// the N-EVENT-REPORT from the remote SCP containing the commitment result.
    /// The listener must be started before calling this method.
    ///
    /// - Parameters:
    ///   - request: The commitment request to wait for
    ///   - timeout: Maximum time to wait for the result
    ///   - listener: The notification listener to use for receiving results
    /// - Returns: The commitment result
    /// - Throws: `DICOMNetworkError.timeout` if the timeout expires before receiving a result
    ///
    /// ## Example Usage
    ///
    /// ```swift
    /// // Create and start the listener
    /// let listenerConfig = CommitmentNotificationListenerConfiguration(
    ///     aeTitle: try AETitle("MY_SCU"),
    ///     port: 11113
    /// )
    /// let listener = CommitmentNotificationListener(configuration: listenerConfig)
    /// try await listener.start()
    ///
    /// // Request commitment
    /// let request = try await StorageCommitmentService.requestCommitment(
    ///     for: references,
    ///     host: "pacs.example.com",
    ///     port: 104,
    ///     configuration: config
    /// )
    ///
    /// // Wait for the result
    /// let result = try await StorageCommitmentService.waitForCommitment(
    ///     request: request,
    ///     timeout: .seconds(300),
    ///     listener: listener
    /// )
    /// ```
    ///
    /// Reference: PS3.4 Section J.3.2 - N-EVENT-REPORT Service
    public static func waitForCommitment(
        request: CommitmentRequest,
        timeout: Duration,
        listener: CommitmentNotificationListener
    ) async throws -> CommitmentResult {
        try await listener.waitForResult(transactionUID: request.transactionUID, timeout: timeout)
    }
    
    /// Parses a commitment result from an N-EVENT-REPORT data set
    ///
    /// This method parses the data set received in an N-EVENT-REPORT request
    /// to extract the commitment result information.
    ///
    /// - Parameters:
    ///   - eventTypeID: The event type ID (1 = success, 2 = failures exist)
    ///   - dataSet: The data set containing commitment results
    ///   - remoteAETitle: The AE title of the sender
    /// - Returns: The parsed commitment result
    /// - Throws: `DICOMNetworkError.decodingFailed` if parsing fails
    public static func parseCommitmentResult(
        eventTypeID: UInt16,
        dataSet: Data,
        remoteAETitle: String
    ) throws -> CommitmentResult {
        // Parse Transaction UID (0008,1195)
        guard let transactionUID = extractUIValue(from: dataSet, tag: Tag(group: 0x0008, element: 0x1195)) else {
            throw DICOMNetworkError.decodingFailed("Missing Transaction UID in commitment result")
        }
        
        var committedReferences: [SOPReference] = []
        var failedReferences: [FailedSOPReference] = []
        
        // Parse Referenced SOP Sequence (0008,1199) - committed instances
        if let sequenceItems = extractSequenceItems(from: dataSet, tag: Tag(group: 0x0008, element: 0x1199)) {
            for item in sequenceItems {
                if let sopClassUID = extractUIValue(from: item, tag: Tag(group: 0x0008, element: 0x1150)),
                   let sopInstanceUID = extractUIValue(from: item, tag: Tag(group: 0x0008, element: 0x1155)) {
                    committedReferences.append(SOPReference(
                        sopClassUID: sopClassUID,
                        sopInstanceUID: sopInstanceUID
                    ))
                }
            }
        }
        
        // Parse Failed SOP Sequence (0008,1198) - failed instances
        if let sequenceItems = extractSequenceItems(from: dataSet, tag: Tag(group: 0x0008, element: 0x1198)) {
            for item in sequenceItems {
                if let sopClassUID = extractUIValue(from: item, tag: Tag(group: 0x0008, element: 0x1150)),
                   let sopInstanceUID = extractUIValue(from: item, tag: Tag(group: 0x0008, element: 0x1155)) {
                    let failureReason = extractUSValue(from: item, tag: Tag(group: 0x0008, element: 0x1197)) ?? 0x0110
                    failedReferences.append(FailedSOPReference(
                        reference: SOPReference(
                            sopClassUID: sopClassUID,
                            sopInstanceUID: sopInstanceUID
                        ),
                        failureReason: failureReason
                    ))
                }
            }
        }
        
        return CommitmentResult(
            transactionUID: transactionUID,
            committedReferences: committedReferences,
            failedReferences: failedReferences,
            remoteAETitle: remoteAETitle
        )
    }
    
    // MARK: - Private Helpers
    
    /// Performs the N-ACTION request/response exchange
    private static func performNAction(
        association: Association,
        presentationContextID: UInt8,
        maxPDUSize: UInt32,
        transactionUID: String,
        references: [SOPReference]
    ) async throws -> NActionResponse {
        // Build the action data set
        let actionDataSet = buildCommitmentRequestDataSet(
            transactionUID: transactionUID,
            references: references
        )
        
        // Create N-ACTION request
        let request = NActionRequest(
            messageID: 1,
            requestedSOPClassUID: storageCommitmentPushModelSOPClassUID,
            requestedSOPInstanceUID: storageCommitmentPushModelSOPInstanceUID,
            actionTypeID: storageCommitmentRequestActionTypeID,
            hasDataSet: true,
            presentationContextID: presentationContextID
        )
        
        // Fragment and send the command and data
        let fragmenter = MessageFragmenter(maxPDUSize: maxPDUSize)
        let pdus = fragmenter.fragmentMessage(
            commandSet: request.commandSet,
            dataSet: actionDataSet,
            presentationContextID: presentationContextID
        )
        
        // Send all PDVs
        for pdu in pdus {
            for pdv in pdu.presentationDataValues {
                try await association.send(pdv: pdv)
            }
        }
        
        // Receive response
        let assembler = MessageAssembler()
        
        while true {
            let responsePDU = try await association.receive()
            
            if let message = try assembler.addPDVs(from: responsePDU) {
                guard message.command == .nActionResponse else {
                    throw DICOMNetworkError.decodingFailed(
                        "Expected N-ACTION-RSP, got \(message.command?.description ?? "unknown")"
                    )
                }
                return NActionResponse(commandSet: message.commandSet, presentationContextID: presentationContextID)
            }
        }
    }
    
    /// Builds the data set for a storage commitment request
    private static func buildCommitmentRequestDataSet(
        transactionUID: String,
        references: [SOPReference]
    ) -> Data {
        var dataSet = Data()
        
        // Transaction UID (0008,1195) - UI
        dataSet.append(encodeUIElement(tag: Tag(group: 0x0008, element: 0x1195), value: transactionUID))
        
        // Referenced SOP Sequence (0008,1199) - SQ
        let referencedSOPSequenceTag = Tag(group: 0x0008, element: 0x1199)
        var sequenceData = Data()
        
        for reference in references {
            var itemData = Data()
            
            // Referenced SOP Class UID (0008,1150) - UI
            itemData.append(encodeUIElement(tag: Tag(group: 0x0008, element: 0x1150), value: reference.sopClassUID))
            
            // Referenced SOP Instance UID (0008,1155) - UI
            itemData.append(encodeUIElement(tag: Tag(group: 0x0008, element: 0x1155), value: reference.sopInstanceUID))
            
            // Encode item
            sequenceData.append(encodeSequenceItem(itemData))
        }
        
        // Append sequence delimiter
        sequenceData.append(encodeSequenceDelimiter())
        
        // Encode sequence element with undefined length
        dataSet.append(encodeSequenceElement(tag: referencedSOPSequenceTag, content: sequenceData))
        
        return dataSet
    }
    
    /// Encodes a UI element in Explicit VR Little Endian
    private static func encodeUIElement(tag: Tag, value: String) -> Data {
        var data = Data()
        
        // Tag (4 bytes, little endian)
        var group = tag.group.littleEndian
        var element = tag.element.littleEndian
        data.append(Data(bytes: &group, count: 2))
        data.append(Data(bytes: &element, count: 2))
        
        // VR (2 bytes)
        data.append(contentsOf: "UI".utf8)
        
        // Pad value to even length
        var valueData = value.data(using: .ascii) ?? Data()
        if valueData.count % 2 != 0 {
            valueData.append(0x00)
        }
        
        // Length (2 bytes for UI)
        var length = UInt16(valueData.count).littleEndian
        data.append(Data(bytes: &length, count: 2))
        
        // Value
        data.append(valueData)
        
        return data
    }
    
    /// Encodes a sequence item
    private static func encodeSequenceItem(_ itemData: Data) -> Data {
        var data = Data()
        
        // Item tag (FFFE,E000)
        data.append(contentsOf: [0xFE, 0xFF, 0x00, 0xE0])
        
        // Item length (4 bytes, little endian)
        var length = UInt32(itemData.count).littleEndian
        data.append(Data(bytes: &length, count: 4))
        
        // Item data
        data.append(itemData)
        
        return data
    }
    
    /// Encodes a sequence delimiter
    private static func encodeSequenceDelimiter() -> Data {
        var data = Data()
        
        // Sequence delimitation item (FFFE,E0DD)
        data.append(contentsOf: [0xFE, 0xFF, 0xDD, 0xE0])
        
        // Length (always 0)
        data.append(contentsOf: [0x00, 0x00, 0x00, 0x00])
        
        return data
    }
    
    /// Encodes a sequence element with undefined length
    private static func encodeSequenceElement(tag: Tag, content: Data) -> Data {
        var data = Data()
        
        // Tag (4 bytes, little endian)
        var group = tag.group.littleEndian
        var element = tag.element.littleEndian
        data.append(Data(bytes: &group, count: 2))
        data.append(Data(bytes: &element, count: 2))
        
        // VR (2 bytes)
        data.append(contentsOf: "SQ".utf8)
        
        // Reserved (2 bytes)
        data.append(contentsOf: [0x00, 0x00])
        
        // Undefined length (4 bytes)
        data.append(contentsOf: [0xFF, 0xFF, 0xFF, 0xFF])
        
        // Sequence content
        data.append(content)
        
        return data
    }
    
    /// Extracts a UI value from data at a specific tag
    private static func extractUIValue(from data: Data, tag: Tag) -> String? {
        var offset = 0
        
        while offset + 8 <= data.count {
            let group = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
            let element = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
            offset += 4
            
            // Check for explicit VR
            let byte0 = data[offset]
            let byte1 = data[offset + 1]
            let possibleVR = String(bytes: [byte0, byte1], encoding: .ascii) ?? ""
            
            let length: Int
            if possibleVR == "UI" || possibleVR == "SH" || possibleVR == "LO" ||
               possibleVR == "CS" || possibleVR == "AE" || possibleVR == "DA" ||
               possibleVR == "TM" || possibleVR == "DS" || possibleVR == "IS" ||
               possibleVR == "PN" || possibleVR == "AS" || possibleVR == "DT" ||
               possibleVR == "ST" || possibleVR == "LT" {
                // Short VR - 2 byte VR + 2 byte length
                length = Int(UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8))
                offset += 4
            } else if possibleVR == "OB" || possibleVR == "OW" || possibleVR == "OF" ||
                      possibleVR == "SQ" || possibleVR == "UC" || possibleVR == "UR" ||
                      possibleVR == "UT" || possibleVR == "UN" {
                // Long VR - 2 byte VR + 2 byte reserved + 4 byte length
                offset += 4
                length = Int(UInt32(data[offset]) |
                            (UInt32(data[offset + 1]) << 8) |
                            (UInt32(data[offset + 2]) << 16) |
                            (UInt32(data[offset + 3]) << 24))
                offset += 4
            } else {
                // Implicit VR - 4 byte length
                length = Int(UInt32(data[offset]) |
                            (UInt32(data[offset + 1]) << 8) |
                            (UInt32(data[offset + 2]) << 16) |
                            (UInt32(data[offset + 3]) << 24))
                offset += 4
            }
            
            if group == tag.group && element == tag.element {
                // Found the tag
                if length > 0 && offset + length <= data.count {
                    let valueData = data.subdata(in: offset..<(offset + length))
                    return String(data: valueData, encoding: .ascii)?
                        .trimmingCharacters(in: CharacterSet(charactersIn: " \0"))
                }
                return nil
            }
            
            // Skip value
            if length > 0 && length != 0xFFFFFFFF {
                offset += length
            }
        }
        
        return nil
    }
    
    /// Extracts a US (unsigned short) value from data at a specific tag
    private static func extractUSValue(from data: Data, tag: Tag) -> UInt16? {
        var offset = 0
        
        while offset + 8 <= data.count {
            let group = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
            let element = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
            offset += 4
            
            let byte0 = data[offset]
            let byte1 = data[offset + 1]
            let possibleVR = String(bytes: [byte0, byte1], encoding: .ascii) ?? ""
            
            let length: Int
            if possibleVR == "US" || possibleVR == "SS" || possibleVR == "AT" {
                length = Int(UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8))
                offset += 4
            } else {
                length = Int(UInt32(data[offset]) |
                            (UInt32(data[offset + 1]) << 8) |
                            (UInt32(data[offset + 2]) << 16) |
                            (UInt32(data[offset + 3]) << 24))
                offset += 4
            }
            
            if group == tag.group && element == tag.element {
                if offset + 2 <= data.count {
                    return UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
                }
                return nil
            }
            
            if length > 0 && length != 0xFFFFFFFF {
                offset += length
            }
        }
        
        return nil
    }
    
    /// Extracts sequence items from data at a specific tag
    private static func extractSequenceItems(from data: Data, tag: Tag) -> [Data]? {
        var offset = 0
        
        // Find the sequence tag
        while offset + 8 <= data.count {
            let group = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
            let element = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
            offset += 4
            
            let byte0 = data[offset]
            let byte1 = data[offset + 1]
            let possibleVR = String(bytes: [byte0, byte1], encoding: .ascii) ?? ""
            
            var sequenceLength: Int = 0
            if possibleVR == "SQ" {
                // Explicit VR SQ
                offset += 4 // Skip VR and reserved
                sequenceLength = Int(UInt32(data[offset]) |
                                    (UInt32(data[offset + 1]) << 8) |
                                    (UInt32(data[offset + 2]) << 16) |
                                    (UInt32(data[offset + 3]) << 24))
                offset += 4
            } else {
                // Implicit VR
                sequenceLength = Int(UInt32(data[offset]) |
                                    (UInt32(data[offset + 1]) << 8) |
                                    (UInt32(data[offset + 2]) << 16) |
                                    (UInt32(data[offset + 3]) << 24))
                offset += 4
            }
            
            if group == tag.group && element == tag.element {
                // Found the sequence - extract items
                var items: [Data] = []
                let sequenceEnd = sequenceLength == 0xFFFFFFFF ? data.count : offset + sequenceLength
                
                while offset < sequenceEnd && offset + 8 <= data.count {
                    let itemGroup = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
                    let itemElement = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
                    
                    if itemGroup == 0xFFFE && itemElement == 0xE000 {
                        // Item start
                        let itemLength = Int(UInt32(data[offset + 4]) |
                                            (UInt32(data[offset + 5]) << 8) |
                                            (UInt32(data[offset + 6]) << 16) |
                                            (UInt32(data[offset + 7]) << 24))
                        offset += 8
                        
                        if itemLength == 0xFFFFFFFF {
                            // Undefined length item - find delimiter
                            let itemStart = offset
                            while offset + 8 <= data.count {
                                let delimGroup = UInt16(data[offset]) | (UInt16(data[offset + 1]) << 8)
                                let delimElement = UInt16(data[offset + 2]) | (UInt16(data[offset + 3]) << 8)
                                if delimGroup == 0xFFFE && delimElement == 0xE00D {
                                    items.append(data.subdata(in: itemStart..<offset))
                                    offset += 8
                                    break
                                }
                                offset += 1
                            }
                        } else if offset + itemLength <= data.count {
                            items.append(data.subdata(in: offset..<(offset + itemLength)))
                            offset += itemLength
                        }
                    } else if itemGroup == 0xFFFE && itemElement == 0xE0DD {
                        // Sequence delimiter
                        break
                    } else {
                        break
                    }
                }
                
                return items.isEmpty ? nil : items
            }
            
            // Skip to next element
            if sequenceLength > 0 && sequenceLength != 0xFFFFFFFF {
                offset += sequenceLength
            }
        }
        
        return nil
    }
}

import Network

// MARK: - Commitment Notification Listener

/// Listener for receiving N-EVENT-REPORT notifications for storage commitment
///
/// The Commitment Notification Listener starts a DICOM SCP that listens for incoming
/// N-EVENT-REPORT messages containing storage commitment results from remote SCPs.
///
/// ## Example Usage
///
/// ```swift
/// let config = CommitmentNotificationListenerConfiguration(
///     aeTitle: try AETitle("MY_SCU"),
///     port: 11113
/// )
/// let listener = CommitmentNotificationListener(configuration: config)
///
/// // Start listening
/// try await listener.start()
///
/// // Wait for a specific commitment result
/// let result = try await listener.waitForResult(
///     transactionUID: request.transactionUID,
///     timeout: .seconds(300)
/// )
///
/// // Stop when done
/// await listener.stop()
/// ```
///
/// Reference: PS3.4 Section J.3.2 - N-EVENT-REPORT Service
public actor CommitmentNotificationListener {
    
    /// Listener configuration
    public let configuration: CommitmentNotificationListenerConfiguration
    
    /// The network listener
    private var listener: NWListener?
    
    /// Active associations
    private var activeAssociations: [ObjectIdentifier: CommitmentListenerAssociation] = [:]
    
    /// Pending commitment waiters (transaction UID -> continuation)
    private var pendingWaiters: [String: CheckedContinuation<CommitmentResult, Error>] = [:]
    
    /// Received results that haven't been waited for yet
    private var pendingResults: [String: CommitmentResult] = [:]
    
    /// Event stream continuation
    private var eventContinuation: AsyncStream<CommitmentNotificationListenerEvent>.Continuation?
    
    /// Whether the listener is running
    public private(set) var isRunning: Bool = false
    
    /// Creates a Commitment Notification Listener
    ///
    /// - Parameter configuration: The listener configuration
    public init(configuration: CommitmentNotificationListenerConfiguration) {
        self.configuration = configuration
    }
    
    /// Event stream for monitoring listener activity
    public var events: AsyncStream<CommitmentNotificationListenerEvent> {
        AsyncStream { continuation in
            self.eventContinuation = continuation
            continuation.onTermination = { @Sendable _ in
                Task { await self.handleStreamTermination() }
            }
        }
    }
    
    /// Starts the listener
    ///
    /// - Throws: `DICOMNetworkError.connectionFailed` if listener fails to start
    public func start() async throws {
        guard !isRunning else {
            throw DICOMNetworkError.invalidState("Listener is already running")
        }
        
        let parameters = NWParameters.tcp
        parameters.allowLocalEndpointReuse = true
        
        guard let port = NWEndpoint.Port(rawValue: configuration.port) else {
            throw DICOMNetworkError.invalidPDU("Invalid port: \(configuration.port)")
        }
        
        let listener = try NWListener(using: parameters, on: port)
        self.listener = listener
        
        listener.stateUpdateHandler = { [weak self] state in
            Task { await self?.handleListenerState(state) }
        }
        
        listener.newConnectionHandler = { [weak self] connection in
            Task { await self?.handleNewConnection(connection) }
        }
        
        listener.start(queue: .global(qos: .userInitiated))
        isRunning = true
        
        eventContinuation?.yield(.started(port: configuration.port))
    }
    
    /// Stops the listener
    public func stop() async {
        guard isRunning else { return }
        
        listener?.cancel()
        listener = nil
        
        // Close all active associations
        for association in activeAssociations.values {
            await association.abort()
        }
        activeAssociations.removeAll()
        
        // Cancel all pending waiters
        for (_, continuation) in pendingWaiters {
            continuation.resume(throwing: DICOMNetworkError.connectionClosed)
        }
        pendingWaiters.removeAll()
        pendingResults.removeAll()
        
        isRunning = false
        eventContinuation?.yield(.stopped)
        eventContinuation?.finish()
    }
    
    /// Number of active associations
    public var activeAssociationCount: Int {
        activeAssociations.count
    }
    
    /// Waits for a commitment result with the specified transaction UID
    ///
    /// - Parameters:
    ///   - transactionUID: The transaction UID to wait for
    ///   - timeout: Maximum time to wait
    /// - Returns: The commitment result
    /// - Throws: `DICOMNetworkError.timeout` if the timeout expires
    public func waitForResult(transactionUID: String, timeout: Duration) async throws -> CommitmentResult {
        // Check if result is already available
        if let result = pendingResults.removeValue(forKey: transactionUID) {
            return result
        }
        
        // Wait for the result with timeout
        return try await withThrowingTaskGroup(of: CommitmentResult.self) { group in
            group.addTask {
                try await withCheckedThrowingContinuation { continuation in
                    Task {
                        await self.registerWaiter(transactionUID: transactionUID, continuation: continuation)
                    }
                }
            }
            
            group.addTask {
                try await Task.sleep(for: timeout)
                throw DICOMNetworkError.timeout
            }
            
            guard let result = try await group.next() else {
                throw DICOMNetworkError.timeout
            }
            
            group.cancelAll()
            return result
        }
    }
    
    // MARK: - Internal Methods
    
    /// Registers a waiter for a commitment result
    private func registerWaiter(
        transactionUID: String,
        continuation: CheckedContinuation<CommitmentResult, Error>
    ) {
        // Check if result already arrived
        if let result = pendingResults.removeValue(forKey: transactionUID) {
            continuation.resume(returning: result)
            return
        }
        
        pendingWaiters[transactionUID] = continuation
    }
    
    /// Called when a commitment result is received
    func receiveResult(_ result: CommitmentResult) {
        eventContinuation?.yield(.resultReceived(result))
        
        // Check if someone is waiting for this result
        if let continuation = pendingWaiters.removeValue(forKey: result.transactionUID) {
            continuation.resume(returning: result)
        } else {
            // Store for later retrieval
            pendingResults[result.transactionUID] = result
        }
    }
    
    // MARK: - Private Methods
    
    private func handleStreamTermination() {
        eventContinuation = nil
    }
    
    private func handleListenerState(_ state: NWListener.State) {
        switch state {
        case .failed(let error):
            eventContinuation?.yield(.error(DICOMNetworkError.connectionFailed(error.localizedDescription)))
        case .cancelled:
            isRunning = false
        default:
            break
        }
    }
    
    private func handleNewConnection(_ connection: NWConnection) async {
        // Check if we've reached the maximum number of associations
        guard activeAssociations.count < configuration.maxConcurrentAssociations else {
            connection.cancel()
            return
        }
        
        // Create a new association handler
        let association = CommitmentListenerAssociation(
            connection: connection,
            configuration: configuration,
            eventHandler: { [weak self] event in
                await self?.handleAssociationEvent(event)
            },
            resultHandler: { [weak self] result in
                await self?.receiveResult(result)
            },
            completionHandler: { [weak self] completedAssociation in
                await self?.removeAssociationAsync(completedAssociation)
            }
        )
        
        let id = ObjectIdentifier(association)
        activeAssociations[id] = association
        
        // Start handling the association
        await association.start()
    }
    
    private func handleAssociationEvent(_ event: CommitmentNotificationListenerEvent) {
        eventContinuation?.yield(event)
    }
    
    nonisolated func removeAssociation(_ association: CommitmentListenerAssociation) {
        Task {
            await removeAssociationAsync(association)
        }
    }
    
    private func removeAssociationAsync(_ association: CommitmentListenerAssociation) {
        let id = ObjectIdentifier(association)
        activeAssociations.removeValue(forKey: id)
    }
}

// MARK: - Commitment Listener Association

/// Handles a single association for the Commitment Notification Listener
actor CommitmentListenerAssociation {
    private let connection: NWConnection
    private let configuration: CommitmentNotificationListenerConfiguration
    private let eventHandler: @Sendable (CommitmentNotificationListenerEvent) async -> Void
    private let resultHandler: @Sendable (CommitmentResult) async -> Void
    private let completionHandler: @Sendable (CommitmentListenerAssociation) async -> Void
    
    private var callingAETitle: String = ""
    private var calledAETitle: String = ""
    private var maxPDUSize: UInt32 = defaultMaxPDUSize
    private var acceptedContexts: [UInt8: String] = [:]
    private var messageAssembler = MessageAssembler()
    private var isReleasing = false
    private var currentMessageID: UInt16 = 1
    
    init(
        connection: NWConnection,
        configuration: CommitmentNotificationListenerConfiguration,
        eventHandler: @escaping @Sendable (CommitmentNotificationListenerEvent) async -> Void,
        resultHandler: @escaping @Sendable (CommitmentResult) async -> Void,
        completionHandler: @escaping @Sendable (CommitmentListenerAssociation) async -> Void
    ) {
        self.connection = connection
        self.configuration = configuration
        self.eventHandler = eventHandler
        self.resultHandler = resultHandler
        self.completionHandler = completionHandler
    }
    
    func start() async {
        connection.start(queue: .global(qos: .userInitiated))
        
        // Wait for connection to be ready
        await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
            connection.stateUpdateHandler = { state in
                switch state {
                case .ready:
                    continuation.resume()
                case .failed, .cancelled:
                    continuation.resume()
                default:
                    break
                }
            }
        }
        
        guard connection.state == .ready else {
            await completionHandler(self)
            return
        }
        
        // Handle the association
        do {
            try await handleAssociation()
        } catch {
            await eventHandler(.error(error))
        }
        
        await completionHandler(self)
    }
    
    func abort() async {
        connection.cancel()
    }
    
    // MARK: - Association Handling
    
    private func handleAssociation() async throws {
        // Receive and process A-ASSOCIATE-RQ
        let requestPDU = try await receivePDU()
        
        guard let associateRequest = requestPDU as? AssociateRequestPDU else {
            // Unexpected PDU type - abort
            let abortPDU = AbortPDU(source: .serviceProvider, reason: AbortReason.unexpectedPDU.rawValue)
            try await sendPDU(abortPDU)
            return
        }
        
        callingAETitle = associateRequest.callingAETitle
        calledAETitle = associateRequest.calledAETitle
        maxPDUSize = min(associateRequest.maxPDUSize, configuration.maxPDUSize)
        
        // Check if calling AE is allowed
        if !configuration.isCallingAEAllowed(callingAETitle) {
            await eventHandler(.associationRejected(callingAE: callingAETitle, reason: "AE not allowed"))
            let rejectPDU = AssociateRejectPDU(
                result: .rejectedPermanent,
                source: .serviceProviderACSE,
                reason: 3 // Calling AE Title not recognized
            )
            try await sendPDU(rejectPDU)
            return
        }
        
        // Accept the association with Storage Commitment support
        let acceptedContexts = processAssociationRequest(associateRequest)
        
        if acceptedContexts.isEmpty {
            await eventHandler(.associationRejected(callingAE: callingAETitle, reason: "No supported presentation contexts"))
            let rejectPDU = AssociateRejectPDU(
                result: .rejectedPermanent,
                source: .serviceProviderPresentation,
                reason: 1 // No reason given
            )
            try await sendPDU(rejectPDU)
            return
        }
        
        self.acceptedContexts = acceptedContexts
        
        // Build and send A-ASSOCIATE-AC
        let acceptPDU = buildAssociateAcceptPDU(request: associateRequest, acceptedContexts: acceptedContexts)
        try await sendPDU(acceptPDU)
        
        await eventHandler(.associationEstablished(callingAE: callingAETitle))
        
        // Process messages until release or abort
        while !isReleasing {
            let pdu = try await receivePDU()
            
            switch pdu {
            case _ as ReleaseRequestPDU:
                // Send release response
                let releasePDU = ReleaseResponsePDU()
                try await sendPDU(releasePDU)
                isReleasing = true
                await eventHandler(.associationReleased(callingAE: callingAETitle))
                
            case _ as AbortPDU:
                isReleasing = true
                await eventHandler(.associationReleased(callingAE: callingAETitle))
                
            case let dataPDU as DataTransferPDU:
                try await processDataPDU(dataPDU)
                
            default:
                break
            }
        }
    }
    
    private func processAssociationRequest(_ request: AssociateRequestPDU) -> [UInt8: String] {
        var accepted: [UInt8: String] = [:]
        
        for context in request.presentationContexts {
            // Only accept Storage Commitment Push Model
            if context.abstractSyntax == storageCommitmentPushModelSOPClassUID {
                // Accept with first supported transfer syntax
                for transferSyntax in context.transferSyntaxes {
                    if transferSyntax == explicitVRLittleEndianTransferSyntaxUID ||
                       transferSyntax == implicitVRLittleEndianTransferSyntaxUID {
                        accepted[context.id] = transferSyntax
                        break
                    }
                }
            }
        }
        
        return accepted
    }
    
    private func buildAssociateAcceptPDU(
        request: AssociateRequestPDU,
        acceptedContexts: [UInt8: String]
    ) -> AssociateAcceptPDU {
        var acceptedPresentationContexts: [PresentationContextAccept] = []
        
        for context in request.presentationContexts {
            if let transferSyntax = acceptedContexts[context.id] {
                acceptedPresentationContexts.append(PresentationContextAccept(
                    id: context.id,
                    result: .acceptance,
                    transferSyntax: transferSyntax
                ))
            } else {
                acceptedPresentationContexts.append(PresentationContextAccept(
                    id: context.id,
                    result: .abstractSyntaxNotSupported,
                    transferSyntax: context.transferSyntaxes.first ?? implicitVRLittleEndianTransferSyntaxUID
                ))
            }
        }
        
        return AssociateAcceptPDU(
            calledAETitle: request.calledAETitle,
            callingAETitle: request.callingAETitle,
            applicationContextName: request.applicationContextName,
            presentationContexts: acceptedPresentationContexts,
            maxPDUSize: maxPDUSize,
            implementationClassUID: configuration.implementationClassUID,
            implementationVersionName: configuration.implementationVersionName
        )
    }
    
    private func processDataPDU(_ dataPDU: DataTransferPDU) async throws {
        // Assemble the message
        guard let message = try messageAssembler.addPDVs(from: dataPDU) else {
            return // Need more PDVs
        }
        
        // Process based on command type
        switch message.command {
        case .nEventReportRequest:
            try await processNEventReportRequest(message)
        default:
            // Unsupported command - send error response
            break
        }
    }
    
    private func processNEventReportRequest(_ message: AssembledMessage) async throws {
        let commandSet = message.commandSet
        
        guard let eventTypeID = commandSet.eventTypeID else {
            throw DICOMNetworkError.decodingFailed("Missing Event Type ID in N-EVENT-REPORT")
        }
        
        let messageID = commandSet.messageID ?? 0
        let affectedSOPClassUID = commandSet.affectedSOPClassUID ?? storageCommitmentPushModelSOPClassUID
        let affectedSOPInstanceUID = commandSet.affectedSOPInstanceUID ?? storageCommitmentPushModelSOPInstanceUID
        
        // Parse the commitment result from the data set
        if let dataSet = message.dataSet {
            do {
                let result = try StorageCommitmentService.parseCommitmentResult(
                    eventTypeID: eventTypeID,
                    dataSet: dataSet,
                    remoteAETitle: callingAETitle
                )
                
                // Deliver the result
                await resultHandler(result)
                
                // Send success response
                let response = NEventReportResponse(
                    messageIDBeingRespondedTo: messageID,
                    affectedSOPClassUID: affectedSOPClassUID,
                    affectedSOPInstanceUID: affectedSOPInstanceUID,
                    eventTypeID: eventTypeID,
                    status: .success,
                    hasDataSet: false,
                    presentationContextID: message.presentationContextID
                )
                
                try await sendNEventReportResponse(response)
            } catch {
                // Send error response
                let response = NEventReportResponse(
                    messageIDBeingRespondedTo: messageID,
                    affectedSOPClassUID: affectedSOPClassUID,
                    affectedSOPInstanceUID: affectedSOPInstanceUID,
                    eventTypeID: eventTypeID,
                    status: .processingFailure,
                    hasDataSet: false,
                    presentationContextID: message.presentationContextID
                )
                
                try await sendNEventReportResponse(response)
            }
        }
    }
    
    private func sendNEventReportResponse(_ response: NEventReportResponse) async throws {
        let fragmenter = MessageFragmenter(maxPDUSize: maxPDUSize)
        let pdus = fragmenter.fragmentMessage(
            commandSet: response.commandSet,
            dataSet: nil,
            presentationContextID: response.presentationContextID
        )
        
        for pdu in pdus {
            try await sendPDU(pdu)
        }
    }
    
    // MARK: - PDU I/O
    
    private func receivePDU() async throws -> any PDU {
        return try await withCheckedThrowingContinuation { continuation in
            connection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { data, _, _, error in
                if let error = error {
                    continuation.resume(throwing: DICOMNetworkError.connectionFailed(error.localizedDescription))
                    return
                }
                
                guard let data = data, !data.isEmpty else {
                    continuation.resume(throwing: DICOMNetworkError.connectionClosed)
                    return
                }
                
                do {
                    let pdu = try PDUDecoder.decode(from: data)
                    continuation.resume(returning: pdu)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    
    private func sendPDU(_ pdu: any PDU) async throws {
        let data = pdu.encode()
        
        return try await withCheckedThrowingContinuation { continuation in
            connection.send(content: data, completion: .contentProcessed { error in
                if let error = error {
                    continuation.resume(throwing: DICOMNetworkError.connectionFailed(error.localizedDescription))
                } else {
                    continuation.resume()
                }
            })
        }
    }
}

#endif
